extends Sprite2D

# This script demonstrates how to load and use assets generated by SpriteShift AI.
# It now includes API integration to fetch assets dynamically.

@export var debug_draw_hitboxes: bool = false

# We no longer export these, as they will be fetched from the API.
var sprite_sheet_path: String
var metadata_path: String

var animations: Dictionary = {}
var current_animation: String = "idle"
var current_frame: int = 0
var frame_timer: float = 0.0

# API Client and state management
var api_client: Node
var polling_timer: Timer
var current_job_id: String
var hitbox_container: Node2D

func _ready():
	# This function is called when the node enters the scene tree.
	# Add the API client as a child node.
	api_client = load("res://APIClient.gd").new()
	add_child(api_client)

	# Create a container for hitboxes.
	hitbox_container = Node2D.new()
	hitbox_container.name = "HitboxContainer"
	add_child(hitbox_container)

	# Create a timer for polling the job status.
	polling_timer = Timer.new()
	polling_timer.wait_time = 5.0 # Poll every 5 seconds
	polling_timer.one_shot = false
	polling_timer.timeout.connect(self._on_polling_timer_timeout)
	add_child(polling_timer)

	# Connect to the API client's signals.
	api_client.upload_complete.connect(self._on_upload_complete)
	api_client.status_checked.connect(self._on_status_checked)
	api_client.export_finished.connect(self._on_export_finished)
	api_client.upload_failed.connect(self._on_api_error)
	api_client.status_check_failed.connect(self._on_api_error)
	api_client.export_failed.connect(self._on_api_error)

	# Start the process of loading a character from the API.
	# In a real game, you would get the image path from user input.
	# For this example, we'll use a placeholder path.
	load_character_from_api("res://assets/character_art.png")

func _process(delta):
	# This function is called every frame.
	# We update the animation frame based on the time elapsed.
	if animations:
		frame_timer -= delta
		if frame_timer <= 0:
			advance_frame()

func load_character_from_api(image_path: String):
	print("Starting character generation from image: ", image_path)
	# You would need to set your actual API key here.
	api_client.set_api_key("YOUR_API_KEY_HERE")
	api_client.upload_image(image_path, "user-123")

func _on_upload_complete(job_id: String):
	print("Upload complete. Job ID: ", job_id)
	self.current_job_id = job_id
	polling_timer.start()

func _on_polling_timer_timeout():
	print("Polling for job status...")
	api_client.get_job_status(current_job_id)

func _on_status_checked(status_data):
	var progress = status_data.get("progress_percent", 0)
	print("Job progress: ", progress, "%")
	if progress == 100:
		polling_timer.stop()
		print("Job complete. Exporting assets...")
		api_client.export_assets(current_job_id)

func _on_export_finished(p_sprite_sheet_path: String, p_metadata_path: String):
	print("Assets downloaded successfully.")
	self.sprite_sheet_path = p_sprite_sheet_path
	self.metadata_path = p_metadata_path
	load_character_data()
	play_animation("idle")

func _on_api_error(error_message: String):
	print("An API error occurred: ", error_message)
	polling_timer.stop()

func load_character_data():
	# Load the sprite sheet texture from the user:// directory.
	var texture = load(sprite_sheet_path)
	if texture:
		self.texture = texture
	else:
		print("Error: Could not load sprite sheet at ", sprite_sheet_path)
		return

	# Load and parse the animation metadata JSON file from the user:// directory.
	var file = FileAccess.open(metadata_path, FileAccess.READ)
	if file:
		var json_data = JSON.parse_string(file.get_as_text())
		if json_data and json_data.has("animations"):
			animations = json_data["animations"]
			hframes = json_data.get("h_frames", 1)
			vframes = json_data.get("v_frames", 1)
		else:
			print("Error: Invalid JSON format in ", metadata_path)
	else:
		print("Error: Could not load metadata file at ", metadata_path)

func play_animation(anim_name: String):
	# Plays a new animation if it exists.
	if animations.has(anim_name) and current_animation != anim_name:
		current_animation = anim_name
		current_frame = 0
		advance_frame()

func advance_frame():
	# Advances to the next frame in the current animation sequence.
	var anim_data = animations.get(current_animation)
	if not anim_data:
		return

	var frame_index = anim_data["frames"][current_frame]
	self.frame = frame_index # Set the visible frame of the sprite sheet.

	frame_timer = anim_data["durations"][current_frame]

	current_frame = (current_frame + 1) % len(anim_data["frames"])

	# Update the character's hitboxes for the new frame.
	update_hitboxes(frame_index)

func update_hitboxes(frame_index: int):
	# Clear any old hitboxes.
	for child in hitbox_container.get_children():
		child.queue_free()

	var anim_data = animations.get(current_animation)
	if not anim_data or not anim_data.has("hitboxes"):
		queue_redraw() # Redraw to clear old debug visuals
		return

	# Only create hitboxes for attack animations.
	if not current_animation.begins_with("punch") and not current_animation.begins_with("kick"):
		queue_redraw()
		return

	var hitboxes_for_frame = anim_data["hitboxes"].get(str(frame_index))
	if not hitboxes_for_frame:
		queue_redraw() # Redraw to clear old debug visuals
		return

	# Create new hitbox areas for the current frame's hitboxes.
	for hitbox_data in hitboxes_for_frame:
		var hitbox_area = Area2D.new()
		hitbox_area.collision_layer = 1 # Hitboxes are on layer 1
		hitbox_area.collision_mask = 2  # Scan for hurtboxes on layer 2

		var collision_shape = CollisionShape2D.new()
		var rectangle_shape = RectangleShape2D.new()

		var hitbox_rect = Rect2(
			hitbox_data["x"],
			hitbox_data["y"],
			hitbox_data["width"],
			hitbox_data["height"]
		)

		var sprite_size = texture.get_size() / Vector2(hframes, vframes)
		rectangle_shape.size = hitbox_rect.size
		collision_shape.shape = rectangle_shape
		collision_shape.position = hitbox_rect.position - sprite_size / 2.0

		hitbox_area.add_child(collision_shape)

		# Add a damage property to the hitbox.
		hitbox_area.set_meta("damage", 10)

		hitbox_container.add_child(hitbox_area)

	queue_redraw() # Trigger a redraw to show the new hitboxes.

func _draw():
	if debug_draw_hitboxes:
		var hitbox_color = Color(1.0, 0.0, 0.0, 0.5) # Semi-transparent red for hitboxes
		var hurtbox_color = Color(0.0, 1.0, 0.0, 0.5) # Semi-transparent green for hurtboxes

		# Draw hitboxes
		for area in hitbox_container.get_children():
			if area is Area2D:
				for collision_shape in area.get_children():
					if collision_shape is CollisionShape2D:
						var rect_shape = collision_shape.shape as RectangleShape2D
						if rect_shape:
							var rect = Rect2(area.position + collision_shape.position - rect_shape.size / 2.0, rect_shape.size)
							draw_rect(rect, hitbox_color)

		# Draw the character's hurtbox
		var parent_controller = get_parent()
		if parent_controller and parent_controller.has_node("Hurtbox"):
			var hurtbox_area = parent_controller.get_node("Hurtbox")
			for collision_shape in hurtbox_area.get_children():
				if collision_shape is CollisionShape2D:
					var rect_shape = collision_shape.shape as RectangleShape2D
					if rect_shape:
						var rect = Rect2(hurtbox_area.position + collision_shape.position - rect_shape.size / 2.0, rect_shape.size)
						draw_rect(rect, hurtbox_color)
